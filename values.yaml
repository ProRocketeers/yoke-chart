# Metadata for the deployment - used mostly for unified name of related resources
# -------------------------------------------------------------------------------
# `namespace` - Kubernetes namespace for deployment
namespace: my-ns
# `service` - name of the application as a whole
service: something
# `component` - "part" of the application
component: app
# `environment` - environment of the deployment
environment: test

# Container values
# ----------------
image:
  # `image.repository` - repository part of the image URL (not including image tag)
  repository: ''
  # `image.tag` - tag of the container image
  tag: ''
  # `image.pullPolicy` - container image pull policy. OPTIONAL, default "IfNotPresent"
  pullPolicy: IfNotPresent
  # `image.pullSecrets` - names of Kubernetes secrets used for pulling the container image. OPTIONAL
  pullSecrets:
    - ''

# `mainContainerName` - name of the main Pod container. OPTIONAL, default "main"
mainContainerName: main-container
# `replicaCount` - fixed amount of replicas of the deployment. OPTIONAL, default 1
# if `autoscaling` is set, this value is ignored
replicaCount: 1
# `args` - container's args - array of string arguments for the image. OPTIONAL
args:
  - ''
# `command` - container's command - array of string commands/parts for the image. OPTIONAL
command:
  - ''
# `ports` - specifies the container's ports. First entry is considered a "main" port.
ports: 
  # `ports.port` - service (and if not overridden, container) port
  - port: 80
  - port: 8080
    # `ports.containerPort` - container port. OPTIONAL - defaults to `ports.port` value 
    containerPort: 8081
    # `ports.expose` - whether to expose the port in Service. OPTIONAL - default `false`
    expose: false
    # `ports.name` - override for the pre-generated port name. OPTIONAL
    name: metrics

# Environment variables
# `envs` - key-value pairs of literal environment values. OPTIONAL
envs: 
  MY_ENV: value
# `envsRaw` - environment variables in raw form as described by Kubernetes. OPTIONAL
envsRaw: # optional
  - name: MY_NODE_NAME
    valueFrom:
      fieldRef:
        fieldPath: spec.nodeName
  - name: MY_CPU_REQUEST
    valueFrom:
      resourceFieldRef:
        containerName: test-container
        resource: requests.cpu
  - name: UI_PROPERTIES_FILE_NAME
    valueFrom:
      configMapKeyRef:
        name: game-demo
        key: ui_properties_file_name
# `kubeSecrets` - mapping of Kubernetes Secrets to environment variables. OPTIONAL
kubeSecrets:
  # Kubernetes secret name
  secretNameOne:
    # Key-value pair of environment variable name to key in the Kubernetes secret
    MY_SECRET_ENV: secretKey
  # If the value is omitted, all keys from the secret are loaded (env variable name is the same as the secret key)
  secretNameTwo: null

# `externalSecrets` - mapping of external secrets via ExternalSecrets Operator to environment variables
externalSecrets:
  - secretStore:
      name: my-store
      kind: ClusterSecretStore
    # refresh interval of the created ExternalSecret. OPTIONAL - defaults to 1 minute
    refreshInterval: 1m
    mapping:
      # Path to the secret - prefix `secret/` is omitted
      path/to/secret:
        # Key-value pair of environment variable name to key in the provider
        MY_SECRET_ENV: key_in_secret
        # If the key is omitted, same name as the env var is assumed
        MY_OTHER_SECRET: null
      # If the mapping value is omitted, all keys from the secret are loaded with the same name
      path/to/another/secret: null

# `resources` - specification of minimum/maximum resources a Pod can get. OPTIONAL
# uses Kubernetes specification
resources:
  requests:
    cpu: 200m
    memory: 100Mi
  limits:
    cpu: 400m
    memory: 200Mi

# `autoscaling` - configures a HorizontalPodAutoscaler, as specified by Kubernetes specification. OPTIONAL
# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/#HorizontalPodAutoscalerSpec
# if specified, `replicaCount` is ignored
autoscaling: {}
  # `autoscaling.scaleTargetRef` is ignored and automatically set to the name of the Deployment

# `strategy` - Deployment strategy, as specified by Kubernetes specification. OPTIONAL
# NOTE - if `kind: StatefulSet` is set, this field is ignored (use `statefulSpec.updateStrategy` object)
strategy:
  type: RollingUpdate # or Recreate
  rollingUpdate:
    maxUnavailable: 25%
    maxSurge: 25%

# `podDisruptionBudget` - configures a PodDisruptionBudget, as specified by Kubernetes specification. OPTIONAL
# https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/#PodDisruptionBudgetSpec
podDisruptionBudget: {}
  # `podDisruptionBudget.selector` is ignored and automatically set Pods related to Deployment

# `readinessProbe` - configures the Container's readiness probe as described by Kubernetes. OPTIONAL
readinessProbe:
  exec:
    command:
      - ''
  httpGet:
    port: 0
    host: ''
    httpHeaders:
      - name: ''
        value: ''
    path: ''
    scheme: ''
  tcpSocket:
    port: 0
    host: ''
  initialDelaySeconds: 0
  terminationGracePeriodSeconds: 0
  periodSeconds: 0
  timeoutSeconds: 0
  failureThreshold: 0
  successThreshold: 0
# `livenessProbe` - configures the Container's liveness probe as described by Kubernetes. OPTIONAL
livenessProbe:
  exec:
    command:
      - ''
  httpGet:
    port: 0
    host: ''
    httpHeaders:
      - name: ''
        value: ''
    path: ''
    scheme: ''
  tcpSocket:
    port: 0
    host: ''
  initialDelaySeconds: 0
  terminationGracePeriodSeconds: 0
  periodSeconds: 0
  timeoutSeconds: 0
  failureThreshold: 0
  successThreshold: 0
# `lifecycle` - configures Container's lifecycle properties as described by Kubernetes. OPTIONAL
lifecycle:
  postStart:
    exec:
      command:
        - ''
    httpGet:
      port: 0
      host: ''
      httpHeaders:
        - name: ''
          value: ''
      path: ''
      scheme: ''
  preStop:
    exec:
      command:
        - ''
    httpGet:
      port: 0
      host: ''
      httpHeaders:
        - name: ''
          value: ''
      path: ''
      scheme: ''

# `initContainers` - array of Init Containers of the deployments. OPTIONAL
initContainers:
    # `initContainers.name` - name of the init container. OPTIONAL - defaults to `init-container-{index}`
  - name: ''
    image:
      # ...
      # `initContainers.inheritMainContainerTag` - if `true`, then it uses main container's image tag. Useful for monorepos maybe. OPTIONAL - default `false`
      inheritMainContainerTag: true
      
    # regular Container specification, like `image`, `lifecycle`, `command`, `args`, `envs`, `ports` etc.
    # init containers do NOT inherit any other properties from top-level config

# `ingress` - Ingress configuration. Exposes a service through a domain name. OPTIONAL
ingress:
  # `ingress.enabled` - OPTIONAL - default `false`
  enabled: true
  annotations: {}
  labels: {}
  rules:
    - host: something.k8s.prorocketeers.com
      http:
        paths:
          - path: /
            pathType: ImplementationSpecific
            backend:
              service:
                name: service--component--environment
                port:
                  number: 80
  tls: []
  # ... rest of the Ingress spec, like `ingressClassName`

# `volumes` - configuration of Volumes to be potentially created and mounted into Containers
volumes:
  # examples
  # key-value pairs, where key is the volume name (lowercase-kebab-cased), value is the configuration
  standard-volume:
    # `volume.type` - default `tmpfs` in-memory temporary volume (for small volume of data) or `local` for on-disk temporary volume (for larger volume of data). OPTIONAL
    type: tmpfs 
    # `volume.mounts` - key-value pairs, where key is Container name (`<main-container-name>`, `<sidecar-name>` or `<init container name>`) and value describes where to mount the volume
    mounts:
      containerName: 
        # `volume.mounts.volumePath` - subpath within the volume. OPTIONAL - default null (mounts the entire volume)
        volumePath: ''
        # `volume.mounts.containerPath` - where to mount the volume
        containerPath: ''
  raw-volume:
    # Raw volume specification as described by Kubernetes
    type: raw
    mounts: {} # see above
    # `volume.spec` - the raw volume specification, see
    # https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/volume/#Volume
    spec:
      # just example
      configMap:
        name: log-config
        items:
          - key: log_level
            path: log_level
  persistent-volume:
    # Persistent volume configuration
    type: persistent
    mounts:
      containerName:
        volumePath: '' # optional, default nil
        containerPath: ''
    # either
    # `volume.existing` - whether to create a new PersistentVolumeClaim or use pre-existing PVC
    existing: false
    # `volume.accessModes` - requested volume access modes. OPTIONAL - default array ["ReadWriteOnce"]
    accessModes:
      - ReadWriteOnce
    size: 2Gi
    # REQUIRED
    storageClassName: hpe-storage
    # `volume.volumeMode` - type of the volume - Filesystem/Block. OPTIONAL - default `Filesystem`
    volumeMode: Filesystem # optional, default "Filesystem"
    # or
    # existing: true
    # `volume.pvcName` - name of the PersistentVolumeClaim to mount
    pvcName: my-pvc
  secrets-volume:
    # Secrets volume, allowing the user to mount Kubernetes Secrets as files
    type: secret
    # `volume.mode` - file access mode. OPTIONAL - default 0400 (256 if using JSON)
    mode: 0400
    # `volume.secretName` - name of the Kubernetes secret to mount. Must exist beforehand
    secretName: secretName
    mounts: 
      containerName: 
        # no volumePath this time
        containerPath: ''
    # `volume.items` - allows the user to specify which secret keys to mount. If not specified, all secret keys will be mounted.
    items:
      # filePath = key
      FILE_PATH: secretKey
  configmap-volume:
    # ConfigMap volume, allowing the user to mount Kubernetes ConfigMaps as files
    type: configMap
    # `volume.mode` - file access mode. OPTIONAL - default 0400 (256 if using JSON)
    mode: 0400
    # `volume.configMapName` - name of the Kubernetes ConfigMap to mount. Must exist beforehand
    configMapName: configMapName
    mounts: 
      containerName: 
        # no volumePath this time
        containerPath: ''
    # `volume.items` - allows the user to specify which configmap keys to mount. If not specified, all keys will be mounted.
    items:
      # filePath = key
      FILE_PATH: secretKey

# `sidecars` - specifies Containers running alongside of the main container. 
# These will automatically be also mounted into other containers as `/sidecar/{sidecarName}`
sidecars: # optional
  sidecarName:
    image:
      # ...
      # `sidecars.inheritMainContainerTag` - identical function to `initContainers`. OPTIONAL - default `false`
      inheritMainContainerTag: false # optional, default false
    # Regular Container spec, like `initContainers`

# StatefulSet configuration
# -------------------------
# `kind` - specifies, if the main workload is a Deployment (default, also accepted value), or StatefulSet. OPTIONAL - default `Deployment`
kind: StatefulSet

# `statefulSet` - full `StatefulSetSpec` specification as specified by Kubernetes. https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec
# NOTE - some fields are ignored, as they are templated/generated/prepopulated by the Flight - `serviceName`, `selector`, `template`, `replicas`
# the headless Service for the StatefulSet is also generated for you
statefulSet: {}

# used for scraping metrics from the main deployment
serviceMonitor:
  enabled: true
  # structure of this array is taken directly from Prometheus Operator `ServiceMonitor` CRD
  # configurable values are here https://prometheus-operator.dev/docs/api-reference/api/#monitoring.coreos.com/v1.Endpoint
  endpoints:
    # note that this port is NOT automatically created and has to be specified manually in the `ports` array
    - port: metrics
      path: /metrics
      scheme: http
      interval: 15s
      scrapeTimeout: 10s
      honorLabels: false
      honorTimestamps: true

# `preDeploymentJob` - specifies a Kubernetes Job that is run *before* the deployment starts
# it has its own set of config properties - nothing is inherited from top-level config
# useful for preparing the environment of the application, such as DB migrations
preDeploymentJob:
  # container values
  image:
    repository: ''
    tag: ''
    inheritMainContainerTag: false
    pullPolicy: IfNotPresent
    pullSecrets:
      - ''
  mainContainerName: ''
  args: []
  command: []
  # if you want to re-use envs, use YAML anchors
  envs: {}
  envsRaw: {}
  kubeSecrets: {}

  initContainers:
    - name: foo
      # container values
      image:
        # ...
        inheritMainContainerTag: true
  
  # `annotations` - key-value object of the Job's annotations. OPTIONAL
  annotations: {}
  # `podAnnotations` - key-value object of the deployed Pod's annotations. OPTIONAL
  podAnnotations: {}

  # `labels` - key-value object of the Job's labels. OPTIONAL
  labels: {}
  # `podLabels` - key-value object of the deployed Pod's labels. OPTIONAL
  podLabels: {}


  # see above
  volumes: {}

  # similar to main deployment ServiceMonitor, this monitors specifically the job and its Pods
  # NOTE: these pods are usually very short lived, on the order of seconds to minutes at most
  # take in consideration if it's even useful to scrape or not, and if so - set a short interval and scrape timeout
  # so Prometheus can actually even try and scrape it intime
  podMonitor:
    enabled: true
    # properties of this array are slightly different - https://prometheus-operator.dev/docs/api-reference/api#monitoring.coreos.com/v1.PodMetricsEndpoint
    endpoints:
      - port: metrics
        path: /metrics
        scheme: http
        interval: 15s
        scrapeTimeout: 10s
        honorLabels: false
        honorTimestamps: true
  
  # optionally, rest of Kubernetes Job spec (except `template`)
  activeDeadlineSeconds: null
  backoffLimit: null
  completionMode: null
  completions: null
  parallelism: null
  podFailurePolicy: null
  selector: null
  suspend: null
  ttlSecondsAfterFinished: null


# `annotations` - key-value object of the Deployment's annotations. OPTIONAL
annotations: {}
# `podAnnotations` - key-value object of the deployed Pod's annotations. OPTIONAL
podAnnotations: {}

# `labels` - key-value object of the Deployment's labels. OPTIONAL
labels: {}
# `podLabels` - key-value object of the deployed Pod's labels. OPTIONAL
podLabels: {}

# TODO: refactor and split RBAC if needed
# `serviceAccount` - configures the ServiceAccount to be used by the chart's workloads. OPTIONAL
# a ServiceAccount is always created per-chart (and used by all Pods in the chart), with a templated name (same as the main Deployment)
# you can configure its annotations or RBAC rules paired with it
serviceAccount:
  # `serviceAccount.annotations` - annotation to add to the ServiceAccount - key-value object. OPTIONAL
  annotations: {}
  # `serviceAccount.additionalRole` - creates a Role + RoleBinding to the specified ServiceAccount, providing RBAC access to resources in the chart's namespace
  additionalRole:
    # `name` - overrides the name of the Role + RoleBinding to create. OPTIONAL - will be templated otherwise
    name: ""
    rules:
      - apiGroups: [""]
        resources: [""]
        verbs: [""]
  # `serviceAccount.additionalClusterRole` - creates a ClusterRole + ClusterRoleBinding to the specified ServiceAccount, providing RBAC access to resources in the whole cluster
  # use with caution
  additionalClusterRole:
    # `name` - overrides the name of the Role + RoleBinding to create. OPTIONAL - will be templated otherwise
    name: ""
    rules:
      - apiGroups: [""]
        resources: [""]
        verbs: [""]


# `nodeSelector` - selector configuring which Nodes can be used for Deployment. OPTIONAL
nodeSelector: {} # optional

# `tolerations` - array of Tolerations as described by Kubernetes. OPTIONAL
# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
tolerations: []

# `affinity` - Affinity configuration as described by Kubernetes - NodeAffinity | PodAffinity | PodAntiAffinity. OPTIONAL
# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#NodeAffinity
# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodAffinity
# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodAntiAffinity
affinity: {}

# `extraManifests` - array of extra Kubernetes objects (or template strings to be evaluated) to be rendered by the chart. OPTIONAL
# rendered *once*, NOT per deployment, not validated in any way
extraManifests: []

# `db` - renders a Zalando Postgres cluster
db:
  enabled: false
  clusterName: my-db
  replicas: 1
  version: 15
  size: 5Gi
  storageClass: hpe-storageclass
  backup: true
  users:
    # key: user name, value - array of user DB capabilities
    user-name:
      # user flags - see documentation below
      - superuser
      - createdb
  databases:
    # key: database name, value: user name (owner of the database)
    database-name: user-name
  # any additional configuration options as described in Postgres manifest
  # https://postgres-operator.readthedocs.io/en/latest/reference/cluster_manifest/
  additionalConfig: {}

# `cronjobs` - array of CronJobs to be created. OPTIONAL
# just like `preDeploymentJob`, CronJobs have their own set of properties - nothing inherited
cronjobs:
  - name: cronjob
    schedule: "* * * * *"
    image:
      repository: ''
      tag: ''
      inheritMainContainerTag: false

    # supports most container values like `args`, `command`, `envs` ...
    initContainers: []
    volumes: {}

    # same as `preDeploymentJob.podMonitor`
    podMonitor:
      enabled: true
      endpoints:
        - port: metrics
          path: /metrics
          scheme: http
          interval: 15s
          scrapeTimeout: 10s
          honorLabels: false
          honorTimestamps: true

    cronJobAnnotations: {}
    cronJobLabels: {}
    jobAnnotations: {}
    jobLabels: {}
    podAnnotations: {}
    podLabels: {}
    
    # overrides for CronJobSpec
    suspend: false
    timeZone: Europe/Prague
    concurrencyPolicy: Forbid
    startingDeadlineSeconds: 5
    successfulJobsHistoryLimit: 5
    failedJobsHistoryLimit: 2

    # overrides for JobSpec
    activeDeadlineSeconds: null
    backoffLimit: null
    completionMode: null
    completions: null
    parallelism: null
    podFailurePolicy: null
    selector: null
    ttlSecondsAfterFinished: null
    
configMaps:
  # this sets the name of the ConfigMap and gets templated as `{service}--{component}--{env}-{name}`
  name:
    # the content is not templated in any way
    key: content
    otherKey: |
      some
      other
      content
